Разбор основан на Spring boot приложении.
И том, как внутрь него уже сконфигурированного автоматически засунуть свои надстройки.

Начало:
Создать наследник WebSecurityConfigurerAdapter,
отметить его аннотацией @EnableWebSecurity

метод сигнатуры configure(HttpSecurity http) этого класса
переопределяется ради настройки того, где, как и какие
действия требуются при действиях пользователя. например:
Потребовать роль, логин, перекинуть на страничку логаут и тд. и тп.

Коротко о методах

.and() - разбиение между частями
(примеры частей: authorizeRequests(), httpBasic()/formLogin(), logout())

.authorizeRequests()
    и далее
    .antMatchers() - указать форму URL-a
        .authenticated() - чтобы переходя по ним были аутентифицированы
        .hasRole()
        .hasAnyRole()
        .hasAuthority()
        .hasAnyAuthority()
        .hasIpAddress()
        ... И там очень очень много вариаций, проще в документации посмотреть

.httpBasic() - стандартная логин форма.
.formLogin() - кастомная форма, самостоятельно свёрстанная.
    .loginProcessingUrl() - не адрес странички логина, а адрес обработки логина
    .successForwardUrl() - куда перебросить после удачной аутентификации.
    .successHandler() - обработать пользователя после аутентификации

.logout() -
    .logoutSuccessUrl() - куда после удачного логаута направить

и многое другое...

Схема работы Spring Security:

SecurityContextHolder - к нему можно обратиться отовсюду.
    SecurityContext
        (ThreadLocal Authenticated) (для того, чтобы никто чужой не зашёл)
            Principal, Credentials, Authorities


Прежде чем перейти в DispatcherServlet, который общается с нашими контроллерами,
происходит аутентификация, в длинном конвейере из фильтров.
И когда мы посылаем запрос, он попадает сначала в этот конвейер.

Когда мы настраиваем правила аутентификации - мы в том числе модифицируем данный конвейер
Мы вообще посути только тем и занимаемся, что используя наследник WebSecurityConfigurerAdapter
с аннотацией @EnableWebSecurity переделываем FilterChain

// К примеру мы пытаемся получить доступ к защищённому ресурсу.
// Срабатывает фильтр и кидает экспешн, потому что мы не аутентифицированы.
// Включается обработчик исключений, и редиректит нас на страницу логина.
// В запросе есть в Header`е referer. Вот когда залогинимся, оно берёт из
// request информацию из referer, и возвращает нас обратно.



Про автоконфигурацию:

По умолчанию, если мы не настроили свой authentication (к примеру
inMemory, jdbc, dao) спринг даст нам одного пользователя и динамически сгенерированный
пароль.

Как поставить jdbcAuthentication:
1) нужен DataSource для Security.
2) нужен UserDetailsManager бин, поставленный нами, который заменит предоставленный автоконфигурацией.
а точнее, нужен конкретно под базу данных реализованный - JdbcUserDetailsManager.
3) нужна подготовленная база данных, специально под цели Spring.
то-есть, нужно её создать правильно, с правильными таблицами и столбцами.
4) нужна придумать authorities (разница между ролями и правами в префиксах ROLE_ перед ролью. Остальное - права.)
5) а вообще, есть юзеры, у которых есть роли, есть роли, у которых есть права.
Этот способ я не реализовываю, потому что мне нужен другой.


Как поставить daoAuthenticationProvider (МОЙ, НУЖНЫЙ МНЕ СПОСОБ):
1) Правильная база данных (DDL запросы, создающие её находятся в проекте)
2) Сконфигурировать daoAuthenticationProvider bean
3) Создать PasswordEncoder bean


Мелкие заметки:

Principal - краткая информация о пользователе. Можно всунуть в контроллер
Через него можно получить настоящего нашего пользователя.

UserDetailsService - как только мы поставляем подобный бин, спринг перестаёт использовать свой

UserDetails - информация (минимальная) о пользователях, для аутентификации.
Берём своих юзеров и приводим к этому виду